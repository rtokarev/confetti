#include <assert.h>
#include <stdio.h>
#include <inttypes.h>
#include <stdlib.h>

#include <prscfl.h>


void
dumpStructName(FILE *fh, ParamDef *def, char *delim) {
	if (!def)
		return;

	dumpStructName(fh, def->parent, delim);

	if (def->parent) {
		fputs(delim, fh);
		if (def->parent->value.type == arrayType) {
			fputs("val", fh);
			return;
		}
	}

	fputs(def->name, fh);
}

static void
dumpComment(FILE *fh, ParamDef *def, int istab) {
	if (def->comment) {
		ParamDef	*i = def->comment;

		if (i->next) {
			/* multiline comment */
			fprintf(fh, "%s/*\n", istab ? "\t" : "");
			while(i) {
				fprintf(fh, "%s * %s\n", istab ? "\t" : "", i->value.value.commentval);
				i = i->next;
			}
			fprintf(fh, "%s */\n", istab ? "\t" : "");
		} else {
			/* single line comment */
			fprintf(fh, "%s/* %s */\n", istab ? "\t" : "", i->value.value.commentval);
		}
	}
}

void
dumpParamType(FILE *fh, ParamDef *def)
{
	switch(def->value.type) {
		case	int32Type:
			fprintf(fh, "int32_t");
			break;
		case	uint32Type:
			fprintf(fh, "uint32_t");
			break;
		case	int64Type:
			fprintf(fh, "int64_t");
			break;
		case	uint64Type:
			fprintf(fh, "uint64_t");
			break;
		case	doubleType:
			fprintf(fh, "double");
			break;
		case	stringType:
			fprintf(fh, "char *");
			break;
		case	boolType:
			fprintf(fh, "confetti_bool_t");
			break;
		case	structType:
		case	arrayType:
			dumpStructName(fh, def, "_");
			break;
		case	commentType:
			fprintf(stderr, "Unexpected comment");
			exit(1);
			break;
		default:
			fprintf(stderr, "Unknown value.type (%d)\n", def->value.type);
			exit(1);
	}
}

static void
dumpParamDef(FILE *fh, ParamDef *def) {
	dumpComment(fh, def, 1);

	if (def->value.type == builtinType)
		return;

	fprintf(fh, "\t");
	dumpParamType(fh, def);
	fprintf(fh, " %s;\n", def->name);
}

static void
dumpParamList(FILE *fh, ParamDef *def) {
	while(def) {
		dumpParamDef(fh, def);
		def = def->next;
	}
}

static void
dumpStruct(FILE *fh, ParamDef *def) {
	fputs("typedef struct ", fh);
	dumpParamType(fh, def);
	fputs(" {\n", fh);
	fputs("\tunsigned char __confetti_flags;\n\n", fh);
	dumpParamList(fh, def->value.value.structval);
	fputs("} ", fh);
	dumpParamType(fh, def);
	fputs(";\n\n", fh);
}

static void
dumpArray(FILE *fh, ParamDef *def) {
	fputs("typedef struct ", fh);
	dumpParamType(fh, def);
	fputs(" {\n", fh);
	fputs("\tunsigned char __confetti_flags;\n\n", fh);
	fputs("\t", fh);
	dumpParamType(fh, def->value.value.arrayval);
	fputs(" * val;\n", fh);
	fputs("\tuint32_t n;\n", fh);
	fputs("} ", fh);
	dumpParamType(fh, def);
	fputs(";\n\n", fh);

}

static void
dumpRecursive(FILE *fh, ParamDef *def) {
	while(def) {
		switch(def->value.type) {
			case structType:
				dumpRecursive(fh, def->value.value.structval);
				dumpStruct(fh, def);
				break;
			case arrayType:
				dumpComment(fh, def->value.value.arrayval, 0);
				dumpRecursive(fh, def->value.value.arrayval);
				dumpArray(fh, def);
				break;
			default:
				break;
		}

		if (def->parent && def->parent->value.type == arrayType)
			break;

		def = def->next;
	}
}

void 
hDump(FILE *fh, ParamDef *root) {
	fprintf(fh, "#ifndef %s_CFG_H\n", root->name);
	fprintf(fh, "#define %s_CFG_H\n\n", root->name);

	fputs(
		"/*\n"
		" * Autogenerated file, do not edit it!\n"
		" */\n\n"
		"#include <stdio.h>\n"
		"#include <stdbool.h>\n"
		"#include <stdint.h>\n"
		"#include <sys/types.h>\n\n"
		"#ifndef confetti_bool_t\n"
		"#define confetti_bool_t char\n"
		"#endif\n\n",
		fh
	);

	dumpRecursive(fh, root);

	fprintf(fh,
		"#ifndef CNF_FLAG_STRUCT_NEW\n"
		"#define CNF_FLAG_STRUCT_NEW\t0x01\n"
		"#endif\n"
		"#ifndef CNF_FLAG_STRUCT_NOTSET\n"
		"#define CNF_FLAG_STRUCT_NOTSET\t0x02\n"
		"#endif\n"
		"#ifndef CNF_STRUCT_DEFINED\n"
		"#define CNF_STRUCT_DEFINED(s) (((s)->__confetti_flags & CNF_FLAG_STRUCT_NOTSET) == 0)\n"
		"#endif\n\n"
	);

	fprintf(fh, "void init_%s(%s *c);\n\n", root->name, root->name);
	fprintf(fh, "int fill_default_%s(%s *c, unsigned char flags);\n\n", root->name, root->name);
	fprintf(fh, "void swap_%s(struct %s *c1, struct %s *c2);\n\n",
		root->name, root->name, root->name);
	fprintf(fh, "void destroy_%s(%s *c);\n\n", root->name, root->name);
	fprintf(fh, "int parse_cfg_file_%s(%s *c, FILE *fh, int check_rdonly, int *n_accepted, int *n_skipped, int *n_optional);\n\n", root->name, root->name);
	fprintf(fh, "int parse_cfg_buffer_%s(%s *c, char *buffer, int check_rdonly, int *n_accepted, int *n_skipped, int *n_optional);\n\n", root->name, root->name);
	fprintf(fh, "int check_cfg_%s(%s *c);\n\n", root->name, root->name);
	fprintf(fh, "int dup_%s(%s *dst, %s *src);\n\n", root->name, root->name, root->name);
	fprintf(fh, "char *cmp_%s(%s* c1, %s* c2, int only_check_rdonly);\n\n", root->name, root->name, root->name);
	fprintf(fh, "typedef struct %s_iterator_t %s_iterator_t;\n", root->name, root->name);
	fprintf(fh, "%s_iterator_t* %s_iterator_init();\n", root->name, root->name);
	fprintf(fh, "char* %s_iterator_next(%s_iterator_t* i, %s *c, char **v);\n\n", root->name, root->name, root->name);

	fputs("#endif\n", fh);
}
